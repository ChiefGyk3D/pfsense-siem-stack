input {
  udp {
    port => 5140
    codec => plain
    buffer_size => 65536
    receive_buffer_bytes => 33554432
  }
}

filter {
  # Parse the incoming JSON message
  if [event][original] {
    json {
      source => "[event][original]"
      tag_on_failure => ["_jsonparsefailure"]
    }
  } else if [message] {
    json {
      source => "message"
      tag_on_failure => ["_jsonparsefailure"]
    }
  }
  
  # Process successfully parsed JSON
  if "_jsonparsefailure" not in [tags] {
    # Store parsed JSON under suricata.eve namespace (nested structure)
    ruby {
      code => "
        raw = event.get('message')
        if raw.nil? && event.get('[event][original]')
          raw = event.get('[event][original]')
        end
        if raw
          require 'json'
          begin
            parsed = JSON.parse(raw)
            event.set('[suricata][eve]', parsed)
          rescue
          end
        end
      "
    }
    
    # Handle timestamp from nested field
    if [suricata][eve][timestamp] {
      date {
        match => [ "[suricata][eve][timestamp]", "ISO8601" ]
        target => "@timestamp"
      }
    }
    
    # Remove raw message fields
    mutate {
      remove_field => ["message", "[event][original]"]
    }
  }
  
  mutate {
    add_field => { "[@metadata][index_date]" => "%{+YYYY.MM.dd}" }
  }
}

output {
  opensearch {
    hosts => ["http://localhost:9200"]
    index => "suricata-%{[@metadata][index_date]}"
    ssl => false
    ssl_certificate_verification => false
  }
}
