input {
  udp {
    port => 5140
    codec => plain
    buffer_size => 65536
    receive_buffer_bytes => 33554432
  }
}

filter {
  # Parse JSON directly to root level (flat structure)
  # This matches the dashboard field expectations: event_type, src_ip, dest_ip, alert.signature, etc.
  if [event][original] {
    json {
      source => "[event][original]"
      tag_on_failure => ["_jsonparsefailure"]
    }
  } else if [message] {
    # Fallback to message field if event.original not present
    json {
      source => "message"
      tag_on_failure => ["_jsonparsefailure"]
    }
  }
  
  # Process successfully parsed JSON
  if "_jsonparsefailure" not in [tags] {
    # Handle timestamp
    if [timestamp] {
      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
      }
    }
    
    # Keep nested objects intact (alert, tls, http, dns, etc.)
    # These are preserved as-is and dashboard queries reference them directly
    # Example: alert.signature, tls.sni, http.hostname, dns.rrname
    
    # Remove fields we don't need
    mutate {
      remove_field => ["message", "[event][original]"]
    }
  }
  
  mutate {
    add_field => { "[@metadata][index_date]" => "%{+YYYY.MM.dd}" }
  }
}

output {
  opensearch {
    hosts => ["http://localhost:9200"]
    index => "suricata-%{[@metadata][index_date]}"
    ssl => false
    ssl_certificate_verification => false
  }
}
