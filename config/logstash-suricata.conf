input {
  udp {
    port => 5140
    codec => plain
    buffer_size => 65536
    receive_buffer_bytes => 33554432
  }
}

filter {
  # Parse JSON from event.original instead of message field
  # because UDP codec => plain populates event.original but message may be null
  if [event][original] {
    json {
      source => "[event][original]"
      target => "suricata_raw"
      tag_on_failure => ["_jsonparsefailure"]
    }
  } else if [message] {
    # Fallback to message field if event.original not present
    json {
      source => "message"
      target => "suricata_raw"
      tag_on_failure => ["_jsonparsefailure"]
    }
  }
  
  if [suricata_raw] {
    ruby {
      code => '
        raw = event.get("suricata_raw")
        if raw.is_a?(Hash)
          # Extract suricata_interface if present before moving to suricata.eve
          if raw.key?("suricata_interface")
            event.set("[suricata][interface]", raw.delete("suricata_interface"))
          end
          event.set("[suricata][eve]", raw)
        end
      '
    }
    if [suricata][eve][timestamp] {
      date {
        match => [ "[suricata][eve][timestamp]", "ISO8601" ]
        target => "@timestamp"
      }
    }
    mutate {
      remove_field => ["message", "suricata_raw", "[event][original]"]
    }
  }
  
  mutate {
    add_field => { "[@metadata][index_date]" => "%{+YYYY.MM.dd}" }
  }
}

output {
  opensearch {
    hosts => ["http://localhost:9200"]
    index => "suricata-%{[@metadata][index_date]}"
    ssl => false
    ssl_certificate_verification => false
  }
}
